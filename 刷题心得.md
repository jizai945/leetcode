# 心得



## python3中自定义排序

比如leetcode 179 最大数

```python
import functools

def my_test():
    nums_str = ['92', '123', '929', '920']
    compare = lambda x, y: 1 if x + y < y + x else -1
    # nums_str.sort(cmp = compare)  # python2
    nums_str.sort(key=functools.cmp_to_key(compare)) # python3
    print(nums_str)

if __name__ == '__main__':
    my_test()
```



## python中记忆化递归

在 Python 中，有一个实现记忆化递归的神器，就是 functool模块的 lru_cache装饰器，它可以把函数的输入和输出结果缓存住，在后续调用中如果遇到了相同的输入，直接从缓存里面读。顾名思义，它使用的是 LRU （最近最少使用）的缓存淘汰策略。

`@functools.lru_cache(maxsize=None, typed=False)`

例 leetcode87:

```python
class Solution:
    @functools.lru_cache(None) 
    def isScramble(self, s1: str, s2: str) -> bool:
        N = len(s1)
        if N == 0: return True
        if N == 1: return s1 == s2

        if sorted(s1) != sorted(s2):
            return False

        for i in range(1, N):
            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):
                return True
            elif self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):
                return True

        return False

```





