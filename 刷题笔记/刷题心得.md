# 心得



## python3中自定义排序

比如leetcode 179 最大数

```python
import functools

def my_test():
    nums_str = ['92', '123', '929', '920']
    compare = lambda x, y: 1 if x + y < y + x else -1
    # nums_str.sort(cmp = compare)  # python2
    nums_str.sort(key=functools.cmp_to_key(compare)) # python3
    print(nums_str)

if __name__ == '__main__':
    my_test()
```



## python中记忆化递归

在 Python 中，有一个实现记忆化递归的神器，就是 functool模块的 lru_cache装饰器，它可以把函数的输入和输出结果缓存住，在后续调用中如果遇到了相同的输入，直接从缓存里面读。顾名思义，它使用的是 LRU （最近最少使用）的缓存淘汰策略。

`@functools.lru_cache(maxsize=None, typed=False)`

例 leetcode87:

```python
class Solution:
    @functools.lru_cache(None) 
    def isScramble(self, s1: str, s2: str) -> bool:
        N = len(s1)
        if N == 0: return True
        if N == 1: return s1 == s2

        if sorted(s1) != sorted(s2):
            return False

        for i in range(1, N):
            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):
                return True
            elif self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):
                return True

        return False

```





## 学习大佬的滑动窗口模板



![](./huadongchuagnkou.jpg)



```python
def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res

```



## python 中的排序集合SortedSet

参考leetcode 220：

```python

```



## python中有序序列的查找可以使用bisect

参考同上的leetcode220:



## 二维列表的定义

```python
dp = [[0 for i in range(10)] for i in range(10)]       
```



## 堆排序

https://www.jianshu.com/p/801318c77ab5

参考leetcode313

```python
from queue import PriorityQueue as PQ

class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        if n == 1:
            return 1

        num_map = {}
        heap = [1]

        for i in range(n):
            ugly = heapq.heappop(heap)
            for nu in primes:
                tmp = nu*ugly
                if tmp not in num_map:
                    num_map[tmp] = 1
                    heapq.heappush(heap, tmp)


        return ugly
```



可以对列表进行堆插入，但是列表数据顺序不变，只是pop弹出的时候是有顺序的



## c++优先队列 priority_queue

参考leetcode 786

priority_queue 是容器适配器

按照优先级出队，访问队首也是优先级高的元素

**用堆来存储的，用数组模拟的二叉树**, 有大顶堆 小顶堆, **默认是大顶堆**

插入，删除时间复杂度 O(logn)

访问: O(1)

头文件:`#incldue <queue>`

定义: `priority_queue<int>` que;  大顶堆

定义: `priority_queue<int, 容器, 比较方法>` 可以修改成小顶堆

定义: `priority_queue<int, vector<int>, greater<int> >que` ;  **小顶堆**



操作:

+ `que.size()`
+ `que.push()`
+ `que.pop()`
+ `que.top()` 访问堆顶元素
+ `que.empty()`

实例:

```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <functional>
using namespace std;

struct node {
    int x, y;
    // 函数重载小于号
    bool operator< (const node &b) const {
        return this->x < b.x;
    }
};

struct node2 {
    int x, y;
};

struct cmp {
    bool operator() (const node2 &a, const node2 &b) {
        return a.x < b.x;
    }
};

int main() {
    // 自定类型
    // 自定义类型的排序规则需要自己写
    priority_queue<node> que2;
    que2.push((node){5, 6});
    que2.push((node){2, 9});
    que2.push((node){7, 5});
    while (!que2.empty()) {
        cout << que2.top().x << " " << que2.top().y << endl;
        que2.pop();
    }

    // 第二种重载方法
    priority_queue<node2, vector<node2>, cmp> que3;
    que3.push((node2){5, 6});
    que3.push((node2){2, 9});
    que3.push((node2){7, 5});
    while (!que3.empty()) {
        cout << que3.top().x << " " << que3.top().y << endl;
        que3.pop();
    }


    return 0;

    //priority_queue<int> que; // 大顶堆
    priority_queue<int, vector<int>, greater<int>> que; // 小顶堆
    que.push(6);
    que.push(2);
    que.push(5);
    que.push(9);
    que.push(8);
    cout << que.size() << endl;
    while (!que.empty()) {
        cout << que.top() << endl;
        que.pop();
    }


    return 0;
}
```



## python中同时遍历索引和内容

使用 enumerate,例:

```python
for i, score in enumerate(top_scores):
    print(i)
    print(score)
```



## c++function的使用

可以配合lamda表达式，在函数体内写函数

例leetcode 419:

```cpp
class Solution {
public:
    int countBattleships(vector<vector<char>>& board) {
        int m = board.size();
        int n = board[0].size();
        int dir[4][2] = {0, 1, 0, -1, 1, 0, -1 ,0};

        function<int(int, int)> dfs = [&](int x, int y) {
            if (x < 0 || y < 0 || x >= m || y >= n) return 0;
            if (board[x][y] == '.') return 0;
            board[x][y] = '.';

            for (int i = 0; i < 4; i++) {
                dfs(x + dir[i][0], y + dir[i][1]);
            }
            return 1;
        };

        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n ; j ++) {
                res += dfs(i, j);
            }
        }

        return res;
    }
};
```



## c++ sort

对于vector的排序：

从小到大:

```cpp
vector<int>arr(s,s+5);
sort(arr.begin(),arr.end(),less<int>());
```

从大到小:

```cpp
vector<int>arr(s,s+5);
sort(arr.begin(),arr.end(),greater<int>());
```





## c++ emplace_back 比 push_back效率高

下面同样实现尾插的效果， emplace_back效率更高

```cpp
vector<vector<int>> ans;  

ans.emplace_back(initializer_list<int>{nums1[x], nums2[y]});
anp.push_back({nums1[x], nums2[y]})
```

例程： leetcode 373:

```cpp
class Solution {
public:
    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        auto cmp = [&nums1, &nums2](const pair<int, int> & a, const pair<int, int> & b) {
            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];
        };

        int m = nums1.size();
        int n = nums2.size();
        vector<vector<int>> ans;   
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);
        for (int i = 0; i < min(k, m); i++) {
            pq.emplace(i, 0);
        }

        while (k-- > 0 && !pq.empty()) {
            auto [x, y] = pq.top(); 
            pq.pop();
            ans.emplace_back(initializer_list<int>{nums1[x], nums2[y]});
            if (y + 1 < n) {
                pq.emplace(x, y + 1);
            }
        }

        return ans;
    }
};


```



## ctype 字符串操作

头文件：`#include <ctype.h>`

+ int islower(int c)		判断是否是小写字母
+ int isupper(int c)      判断是否是大写字母
+ int tolower(int c)       把大写字母转成小写字母
+ int toupper(int c)      把小写字母转成大写字母



## pair

`pair<int, int> tmp;`

`auto x = make_pair(1, 2);`



## 参加考试

快期中考试了，小开很紧张！现在各大网站上有 个比赛，每个比赛的开始、结束的时间点是知道的。

小开认为，参加越多的比赛，考试就能考的越好（假的）

所以，他想知道他最多能参加几个比赛。

由于小开认为如果要参加一个比赛必须善始善终，而且不能同时参加 个及以上的比赛。



思路，按照结束时间从小到大排序：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

using P = pair<int,int>;

class Exam {
private:
    vector<P>_time;
    vector<int> _dfs;
    int exam_num;
    int _max;
public:
    Exam() {
        int s, e;
        cin >> exam_num;
        _max = 1;
        for (int i = 0; i < exam_num; i++) {
            cin >> s >> e;
            _time.emplace_back(make_pair(s, e));
            _dfs.emplace_back(0);
        }

        sort(_time.begin(), _time.end(), [](P a, P b){
            return a.second < b.second;
        });

        int temp = _time[0].second;
        for (int i = 0; i < exam_num; i++) {
            if (_time[i].first >= temp) {
                _max++;
                temp = _time[i].second;
            }
        }

    }

    ~Exam() {

    }

    int get_max() {
        return _max;
    }

};

int main() {
    Exam e;
    cout << e.get_max() << endl;

    return 0;
}
```

