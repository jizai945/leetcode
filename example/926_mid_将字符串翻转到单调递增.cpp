// 926. 将字符串翻转到单调递增
// 如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。

// 给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。

// 返回使 s 单调递增的最小翻转次数。

 

// 示例 1：

// 输入：s = "00110"
// 输出：1
// 解释：翻转最后一位得到 00111.
// 示例 2：

// 输入：s = "010110"
// 输出：2
// 解释：翻转得到 011111，或者是 000111。
// 示例 3：

// 输入：s = "00011000"
// 输出：2
// 解释：翻转得到 00000000。
 

// 提示：

// 1 <= s.length <= 105
// s[i] 为 '0' 或 '1'

class Solution {
public:
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(), vector<int>(2, 0));
        int oneSums = s[0] == '1'? 1: 0;


        for (int i = 1; i < s.size(); i++) {
            if (s[i] == '0') {
                dp[i][0] = dp[i-1][0] + oneSums;
                oneSums = 0;
                if (s[i-1] == '1') {
                    dp[i][1] = dp[i-1][1] + 1;
                } else {
                    dp[i][1] = min(dp[i-1][1] == 0? 0: dp[i-1][1] + 1, dp[i-1][0]);
                }
            } else {
                oneSums++;
                dp[i][0] = dp[i-1][0];
                dp[i][1] = dp[i-1][1];
            }

            // cout << i << " " << dp[i][0] << " " << dp[i][1] << endl;
        }

        return min(dp[s.size()-1][0], dp[s.size()-1][1]);
    }
};
